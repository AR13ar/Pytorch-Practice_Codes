# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Ae54nbb2n7K-iVz1Y0its_I74gLt75Z
"""

use_cuda = True
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision.datasets as dsets
import torchvision.transforms as transforms
from torch.autograd import Variable

input_size = (3,32,32)
number_of_filters1 = 16
filter_size1 = 3
number_of_filters2 = 128
filter_size2 = 5
padding = 1
stride = 1
hidden_size = 128
num_classes = 10
num_epochs = 10
batch_size = 100
learning_rate = 0.001
nn_input= 900

train_dataset = dsets.CIFAR10(root='./data', train=True, transform= transforms.ToTensor(), download=True)
test_dataset = dsets.CIFAR10(root='./data', train=False, transform= transforms.ToTensor())

train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=True)
test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=False)

class Net(nn.Module):
  def __init__(self, input_size, hidden_size, num_classes):
    super(Net, self).__init__()
    self.conv1 = nn.Conv2d(3, number_of_filters1, filter_size1,stride, padding)
    self.conv2 = nn.Conv2d(number_of_filters1, number_of_filters2, filter_size2, stride, padding)
    self.bn1 = nn.BatchNorm2d(number_of_filters2)
    #self.global_mxpool = nn.AvgPool2d(2,2)
    self.fc1 = nn.Linear(nn_input*number_of_filters2, hidden_size)
    self.relu = nn.ReLU()
    self.fc2 = nn.Linear(hidden_size, num_classes)
  def forward(self,x):
    out = F.relu(self.conv1(x))
    out = self.conv2(out)
    out = F.relu(self.bn1(out))
    out = out.view(-1, nn_input*number_of_filters2)
    #out = self.global_mxpool(out)
    out = self.fc1(out)
    out = self.relu(out)
    out = self.fc2(out)
    return out

net = Net(input_size, hidden_size, num_classes)
criterian = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(net.parameters(), lr = learning_rate)

for epoch in range(num_epochs):
  for i, (images, labels) in enumerate(train_loader):    
    images = Variable(images)
    labels = Variable(labels)
    optimizer.zero_grad()
    outputs = net(images)
    loss = criterian(outputs, labels)
    loss.backward()
    optimizer.step()
    if (i+1)%100 == 0:
          print('Epoch [%d/%d], Step [%d/%d],Loss: %.4f'
#                 %(epoch+1, num_epochs, i+1, len(train_dataset)//batch_size,loss.data))

a = 0
b = 0
for images, labels in test_loader:
    images = Variable(images.view(-1, 32*32*3))    
    outputs = net(images)
    _, predicted = torch.max(outputs.data, 1) 
    b += labels.size(0)               
    a += (predicted == labels).sum()
    
print('Accuracy on test images: %d %%' % (100 * a/ b))

